import * as core from "@actions/core";
import * as exec from "@actions/exec";
import * as http from "@actions/http-client";
import * as path from "path";
import * as crypto from "crypto";
import fs from "fs/promises";

interface FuzzOptions {
  repository: string;
  githubToken: string;
  githubGraphqlUrl: string;
  githubServerUrl: string;
  githubRunId: string | undefined;
  githubRunAttempt: string | undefined;
  baseBranch: string;
  packages: string;
  workingDirectory: string;
  fuzzRegexp: string;
  fuzzTime: string;
  fuzzMinimizeTime: string;
  headBranchPrefix: string;
}

interface FuzzResult {
  TODO: string;
}

export async function fuzz(options: FuzzOptions): Promise<FuzzResult> {
  const exitCode = await core.group("fuzzing", async () => {
    return await exec.exec(
      "go",
      [
        "test",
        `-fuzz=${options.fuzzRegexp}`,
        `-fuzztime=${options.fuzzTime}`,
        `-fuzzminimizetime=${options.fuzzMinimizeTime}`,
        options.packages,
      ],
      { cwd: options.workingDirectory, ignoreReturnCode: true }
    );
  });

  if (exitCode === 0) {
    core.info("no fuzzing error");
    return {
      TODO: "fill me!",
    };
  }

  core.info("fuzzing error occurred");
  await core.group("generate report", async () => {
    await generateReport(options);
  });

  return {
    TODO: "fill me!",
  };
}

async function generateReport(options: FuzzOptions): Promise<void> {
  // const cwd = { cwd: options.workingDirectory };
  const ignoreReturnCode = { cwd: options.workingDirectory, ignoreReturnCode: true };

  const corpus = await getNewCorpus(options);
  if (corpus == null) {
    return;
  }
  core.info(`new corpus found: ${corpus}`);

  const client = new http.HttpClient("shogo82148/actions-go-fuzz", [], {
    headers: {
      Authorization: `Bearer ${options.githubToken}`,
      "X-Github-Next-Global-ID": "1",
    },
  });
  const repositoryId = await getRepositoryId(client, options);
  core.debug(`repositoryId: ${repositoryId}`);

  // create a new branch
  const packageName = await getPackageName(options);
  const segments = corpus.split(path.sep);
  const testFunc = segments[segments.length - 2];
  const testCorpus = segments[segments.length - 1];
  const branchName = `${options.headBranchPrefix}/${packageName}/${testFunc}/${testCorpus}`;
  const oid = await getHeadRef();
  await createBranch(client, options, {
    clientMutationId: newClientMutationId(),
    repositoryId,
    name: `refs/heads/${branchName}`,
    oid,
  });

  const testResult = await exec.getExecOutput(
    "go",
    ["test", `-run=${testFunc}/${testCorpus}`, options.packages],
    ignoreReturnCode
  );

  const contents = await fs.readFile(corpus);

  // create a new commit
  await createCommit(client, options, {
    clientMutationId: newClientMutationId(),
    branch: {
      repositoryNameWithOwner: options.repository,
      branchName,
    },
    fileChanges: {
      additions: [
        {
          path: corpus,
          contents: contents.toString("base64"),
        },
      ],
      deletions: [],
    },
    expectedHeadOid: oid,
    message: {
      headline: `Add a new fuzz data for ${testFunc} in ${packageName}.`,
      body: `${"`"}go test -run=${testFunc}/${testCorpus} ${options.packages}${"`"} failed with the following output:

${"```"}
${testResult.stdout}
${"```"}

This fuzz data is generated by [actions-go-fuzz](https://github.com/shogo82148/actions-go-fuzz).
`,
    },
  });

  // create a new pull request
  const logUrl =
    options.githubRunId != null && options.githubRunAttempt != null
      ? `${options.githubServerUrl}/${options.repository}/actions/runs/${options.githubRunId}/attempts/${options.githubRunAttempt}`
      : undefined;
  await createPullRequest(client, options, {
    clientMutationId: newClientMutationId(),
    repositoryId,
    headRepositoryId: repositoryId,
    baseRefName: options.baseBranch,
    headRefName: branchName,
    maintainerCanModify: true,
    draft: false,
    title: `Fuzz test failed with ${testFunc} in ${packageName}.`,
    body: `${"`"}go test -run=${testFunc}/${testCorpus} ${options.packages}${"`"} failed with the following output:

${"```"}
${testResult.stdout}
${"```"}

---

This pull request is generated by [actions-go-fuzz](https://github.com/shogo82148/actions-go-fuzz).
${logUrl != null ? `\n[See the log](${logUrl}).` : ""}
`,
  });

  // cleanup
  await exec.exec("git", ["restore", "--staged", "."], ignoreReturnCode);
  await fs.unlink(corpus);
}

async function getNewCorpus(options: FuzzOptions): Promise<string | undefined> {
  const cwd = { cwd: options.workingDirectory };
  const ignoreReturnCode = { cwd: options.workingDirectory, ignoreReturnCode: true };

  // check whether there is any changes.
  await exec.exec("git", ["add", "."], cwd);
  const hasChange = await exec.exec("git", ["diff", "--cached", "--exit-code", "--quiet"], ignoreReturnCode);
  if (hasChange === 0) {
    return undefined;
  }

  // find new test corpus.
  const output = await exec.getExecOutput(
    "git",
    ["diff", "--name-only", "--cached", "--no-renames", "--diff-filter=d"],
    cwd
  );
  const testdata = output.stdout.split("\n").filter((file) => {
    {
      const segments = file.split(path.sep);
      return (
        segments.length >= 4 &&
        segments[segments.length - 4] === "testdata" &&
        segments[segments.length - 3] === "fuzz" &&
        segments[segments.length - 2].startsWith("Fuzz")
      );
    }
  });
  if (testdata.length !== 1) {
    return undefined;
  }
  return testdata[0];
}

// getRepositoryId gets the repository id from GitHub GraphQL API.
async function getRepositoryId(client: http.HttpClient, options: FuzzOptions): Promise<string> {
  const [owner, name] = options.repository.split("/");
  const query = {
    // ref. https://docs.github.com/en/graphql/reference/queries#repository
    query: `query ($owner: String!, $name: String!) {
      repository(owner: $owner, name: $name) {
        id
      }
    }`,
    variables: {
      owner,
      name,
    },
  };

  interface Response {
    data: {
      repository: {
        id: string;
      };
    };
  }

  const response = await client.postJson<Response>(options.githubGraphqlUrl, query);
  if (response.result == null) {
    throw new Error("failed to get repository id");
  }
  return response.result.data.repository.id;
}

async function getHeadRef(): Promise<string> {
  const output = await exec.getExecOutput("git", ["rev-parse", "HEAD"]);
  return output.stdout.trim();
}

async function getPackageName(options: FuzzOptions): Promise<string> {
  const output = await exec.getExecOutput("go", ["list", options.packages], { cwd: options.workingDirectory });
  const pkg = output.stdout.trim();
  return pkg;
}

function newClientMutationId(): string {
  return crypto.randomUUID();
}

interface CreateBranchInput {
  clientMutationId: string;
  repositoryId: string;
  name: string;
  oid: string;
}

async function createBranch(client: http.HttpClient, options: FuzzOptions, input: CreateBranchInput): Promise<void> {
  const query = {
    // ref. https://docs.github.com/en/graphql/reference/mutations#createref
    query: `mutation ($input: CreateRefInput!) {
      createRef(input: $input) {
        clientMutationId
      }
    }`,
    variables: {
      input,
    },
  };
  core.debug(`create a branch request: ${JSON.stringify(query)}`);

  const response = await client.postJson(options.githubGraphqlUrl, query);
  core.debug(`create a branch response: ${JSON.stringify(response)}`);
}

interface CreateCommitInput {
  clientMutationId: string;
  branch: {
    repositoryNameWithOwner: string;
    branchName: string;
  };
  fileChanges: {
    additions: {
      path: string;
      contents: string;
    }[];
    deletions: {
      path: string;
    }[];
  };
  expectedHeadOid: string;
  message: {
    headline: string;
    body: string;
  };
}

async function createCommit(client: http.HttpClient, options: FuzzOptions, input: CreateCommitInput): Promise<void> {
  const query = {
    // https://docs.github.com/en/graphql/reference/mutations#createcommitonbranch
    query: `mutation ($input: CreateCommitOnBranchInput!) {
      createCommitOnBranch(input: $input) {
        commit { url }
      }
    }`,
    variables: {
      input,
    },
  };
  core.debug(`create a commit request: ${JSON.stringify(query)}`);

  const response = await client.postJson(options.githubGraphqlUrl, query);
  core.debug(`create a commit response: ${JSON.stringify(response)}`);
}

interface CreatePullRequestInput {
  baseRefName: string;
  body: string;
  clientMutationId: string;
  draft: boolean;
  headRefName: string;
  headRepositoryId: string;
  maintainerCanModify: boolean;
  repositoryId: string;
  title: string;
}

async function createPullRequest(
  client: http.HttpClient,
  options: FuzzOptions,
  input: CreatePullRequestInput
): Promise<void> {
  const query = {
    // https://docs.github.com/en/graphql/reference/mutations#createpullrequest
    query: `mutation ($input: CreatePullRequestInput!) {
      createPullRequest(input: $input) {
        pullRequest { url }
      }
    }`,
    variables: {
      input,
    },
  };
  core.debug(`create a pull request request: ${JSON.stringify(query)}`);

  const response = await client.postJson(options.githubGraphqlUrl, query);
  core.debug(`create a pull request response: ${JSON.stringify(response)}`);
}
